#-*- coding: utf8 -*-
'''
Faraday Penetration Test IDE
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import absolute_import

import datetime
from builtins import str

import json
from tempfile import NamedTemporaryFile

import os
import csv
from base64 import b64encode
from io import BytesIO, StringIO


import pytz
from dateutil import parser
from depot.manager import DepotManager

from faraday.server.fields import FaradayUploadedFile

try:
    from urllib import urlencode
except ImportError:
    from urllib.parse import urlencode

import pytest
from hypothesis import given, strategies as st

from faraday.server.api.modules.vulns import (
    VulnerabilityFilterSet,
    VulnerabilitySchema,
    VulnerabilityView
)
from faraday.server.schemas import NullToBlankString
from tests import factories
from tests.conftest import TEST_DATA
from tests.test_api_workspaced_base import (
    ReadOnlyAPITests
)
from faraday.server.models import (
    VulnerabilityGeneric,
    Vulnerability,
    VulnerabilityWeb,
    CustomFieldsSchema,
    Reference,
    PolicyViolation,
    CommandObject,
    File,
    Host,
    Service
)
from tests.factories import (
    ServiceFactory,
    CommandFactory,
    CommandObjectFactory,
    HostFactory,
    EmptyCommandFactory,
    UserFactory,
    VulnerabilityWebFactory,
    VulnerabilityFactory,
    ReferenceFactory,
    PolicyViolationFactory,
    HostnameFactory,
    WorkspaceFactory,
    CustomFieldsSchemaFactory
)

CURRENT_PATH = os.path.dirname(os.path.abspath(__file__))


def _create_post_data_vulnerability(name, vuln_type, parent_id,
                                    parent_type, refs, policyviolations,
                                    status='opened',
                                    attachments=None, impact=None,
                                    description='desc1234',
                                    confirmed=True, data='data1234',
                                    easeofresolution=
                                    Vulnerability.EASE_OF_RESOLUTIONS[0],
                                    owned=False, resolution='res1234',
                                    severity='critical',
                                    update_controller_action='UI Web',
                                    service_id=None,
                                    tool=""
                                    ):
    if not impact:
        impact = {'accountability': False, 'availability': False,
                  'confidentiality': False,
                  'integrity': False}
    data = {
        'metadata': {
            'update_time': 1508254070.211,
            'update_user': '',
            'update_action': 0,
            'creator': 'UI Web',
            'create_time': 1508254070.211,
            'update_controller_action': update_controller_action,
            'owner': ''},
        'obj_id': '5a60af7f01dde6d3acfa8e9d3bef265c361a49d2',
        'owner': '',
        'parent': parent_id,
        'parent_type': parent_type,
        'type': vuln_type,
        'ws': 'airbnb',
        'confirmed': confirmed,
        'data': data,
        'desc': description,
        'easeofresolution': easeofresolution,
        'impact': impact,
        'name': name,
        'owned': owned,
        'policyviolations': policyviolations,
        'refs': refs,
        'resolution': resolution,
        'severity': severity,
        'status': status,
        '_attachments': {},
        'description': '',
        'protocol': '',
        'version': '',
        'tool': tool
    }

    if vuln_type == 'VulnerabilityWeb':
        data.update({
            "method": "GET",
            "params": "pepe",
            "path": "/pepep",
            "pname": "pepe",
            "query": "queue&dfsa",
            "request": "",
            "response": "",
            "website": "www.pepe.com"})

    if attachments:
        data['_attachments'] = {}
        for attachment in attachments:
            attachment_data = attachment.read()
            if isinstance(attachment_data, str):
                attachment_data = attachment_data.encode('utf-8')
            data['_attachments'][attachment.name] = {
                "content_type": "application/x-shellscript",
                "data": b64encode(attachment_data).decode('utf-8')
            }

    if service_id:
        data.update({
            'service_id': service_id,
        })

    return data


@pytest.mark.usefixtures('logged_user')
class TestListVulnerabilityView(ReadOnlyAPITests):  # TODO migration: use read write api tests
    model = Vulnerability
    factory = factories.VulnerabilityFactory
    api_endpoint = 'vulns'
    #unique_fields = ['ip']
    #update_fields = ['ip', 'description', 'os']
    view_class = VulnerabilityView

    def test_backward_json_compatibility(self, test_client, second_workspace, session):
        new_obj = self.factory.create(workspace=second_workspace)
        session.add(new_obj)
        session.commit()
        res = test_client.get(self.url())
        assert res.status_code == 200
        assert 'vulnerabilities' in res.json
        for vuln in res.json['vulnerabilities']:
            assert set([u'id', u'key', u'value']) == set(vuln.keys())
            object_properties = [
                u'status',
                u'issuetracker',
                u'description',
                u'parent',
                u'tags',
                u'severity',
                u'_rev',
                u'easeofresolution',
                u'owned',
                u'hostnames',
                u'pname',
                u'query',
                u'owner',
                u'path',
                u'data',
                u'response',
                u'refs',
                u'desc',
                u'impact',
                u'confirmed',
                u'name',
                u'service',
                u'obj_id',
                u'type',
                u'policyviolations',
                u'request',
                u'_attachments',
                u'target',
                u'_id',
                u'resolution',
                u'method',
                u'metadata',
                u'website',
                u'params',
            ]
            expected = set(object_properties)
            result = set(vuln['value'].keys())
            assert expected - result == set()

    def test_handles_vuln_with_no_creator(self,
                                          workspace,
                                          test_client,
                                          session):
        # This can happen when a user is deleted but its objects persist
        vuln = self.factory.create(workspace=workspace, creator=None)
        session.add(vuln)
        session.commit()
        res = test_client.get(self.url(vuln))
        assert res.status_code == 200
        assert res.json['owner'] is None

    def test_shows_policy_violations(self, workspace, test_client, session,
                                     policy_violation_factory):
        pvs = policy_violation_factory.create_batch(
            5, workspace=workspace)
        for pv in pvs:
            self.first_object.policy_violation_instances.add(pv)
        session.add(self.first_object)
        session.commit()
        res = test_client.get(self.url(self.first_object))
        assert res.status_code == 200
        assert len(res.json['policyviolations']) == 5
        assert set(res.json['policyviolations']) == {pv.name for pv in pvs}

    def test_shows_refs(self, workspace, test_client, session,
                        reference_factory):
        refs = reference_factory.create_batch(
            5, workspace=workspace)
        for ref in refs:
            self.first_object.reference_instances.add(ref)
        session.commit()
        res = test_client.get(self.url(self.first_object))
        assert res.status_code == 200
        assert len(res.json['refs']) == 5
        assert set(res.json['refs']) == {ref.name for ref in refs}

    @pytest.mark.parametrize('creator_func', [
        (lambda host: factories.VulnerabilityFactory.create(
            workspace=host.workspace, host=host, service=None)),
        (lambda host: factories.VulnerabilityFactory.create(
            workspace=host.workspace, host=None,
            service=factories.ServiceFactory.create(
                workspace=host.workspace, host=host
            ))),
        (lambda host: factories.VulnerabilityWebFactory.create(
            workspace=host.workspace, service=factories.ServiceFactory.create(
                workspace=host.workspace, host=host
            ))),
    ], ids=['standard_vuln_with_host', 'standard_vuln_with_service',
            'web_vuln_with_service'])

    def test_hostnames(self, host_with_hostnames, test_client, session,
                       creator_func):
        vuln = creator_func(host_with_hostnames)
        vuln = self.factory.create(host=host_with_hostnames,
                                   service=None,
                                   workspace=host_with_hostnames.workspace)
        session.commit()
        res = test_client.get(self.url(vuln))
        assert res.status_code == 200
        assert isinstance(res.json['hostnames'], list)
        assert set(res.json['hostnames']) == set(hostname.name for hostname in
                                                 host_with_hostnames.hostnames)

    def test_create_vuln(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['name'] == 'New vulns'
        assert res.json['type'] == 'Vulnerability'
        assert res.json['parent'] == host_with_hostnames.id
        assert res.json['parent_type'] == 'Host'
        assert res.json['desc'] == 'helloworld'
        assert res.json['description'] == 'helloworld'
        assert res.json['severity'] == 'low'

    def test_create_cannot_create_vuln_with_empty_name_fails(
            self, host, session, test_client):
        # I'm using this to test the NonBlankColumn which works for
        # all models. Think twice before removing this test
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='',
            vuln_type='Vulnerability',
            parent_id=host.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='aaa',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 400
        assert b'Shorter than minimum length 1' in res.data

    def test_create_create_vuln_with_empty_desc_success(
            self, host, session, test_client):
        # I'm using this to test the NonBlankColumn which works for
        # all models. Think twice before removing this test
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='Empty desc',
            vuln_type='Vulnerability',
            parent_id=host.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 201

    def test_create_vuln_with_attachments(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        attachment = NamedTemporaryFile(mode="wb+")
        file_content = b'test file'
        attachment.write(file_content)
        attachment.seek(0)
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
            attachments=[attachment]
        )

        res = test_client.post(self.url(), data=raw_data)
        vuln_id = res.json['_id']
        assert res.status_code == 201
        filename = attachment.name.split('/')[-1]
        assert filename in res.json['_attachments']
        attachment.close()
        # check the attachment can be downloaded
        res = test_client.get(self.url() + '{0}/attachment/{1}/'.format(vuln_id, filename))
        assert res.status_code == 200
        assert res.data == file_content

        res = test_client.get(
            self.url() +
            '{0}/attachment/notexistingattachment.png/'.format(vuln_id))
        assert res.status_code == 404

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_update_vuln_add_attachment_on_update(self, test_client, session):
        host = HostFactory.create(workspace=self.workspace)
        vuln = VulnerabilityFactory.create(workspace=self.workspace, host_id=host.id)
        session.add(vuln)
        session.commit()  # flush host_with_hostnames
        attachment = NamedTemporaryFile()
        file_content = b'test file'
        attachment.write(file_content)
        attachment.seek(0)
        raw_data = self._create_put_data(
            'Updated with attachment',
            'Updated vuln',
            'open',
            host.id,
            'Host',
            attachments=[attachment]
        )
        res = test_client.put(self.url(obj=vuln, workspace=self.workspace), data=raw_data)
        assert res.status_code == 200
        filename = attachment.name.split('/')[-1]
        res = test_client.get(
            self.url() + '{0}/attachment/{1}/'.format(vuln.id, filename))
        assert res.status_code == 200
        assert res.data == file_content

        new_attachment = NamedTemporaryFile()
        new_filename = new_attachment.name.split('/')[-1]
        file_content = b'new test file'
        new_attachment.write(file_content)
        new_attachment.seek(0)
        raw_data = self._create_put_data(
            'Updated with attachment',
            'Updated vuln',
            'open',
            host.id,
            'Host',
            attachments=[new_attachment]
        )
        res = test_client.put(self.url(obj=vuln, workspace=self.workspace),
                              data=raw_data)
        assert res.status_code == 200

        # verify that the old file was deleted and the new one exists
        res = test_client.get(
            self.url() + '{0}/attachment/{1}/'.format(vuln.id, filename))
        assert res.status_code == 404
        res = test_client.get(
            self.url() + '{0}/attachment/{1}/'.format(vuln.id, new_filename))
        assert res.status_code == 200
        assert res.data == file_content

    def test_get_attachments_by_vuln(self, test_client, session, workspace):
        vuln = VulnerabilityFactory.create(workspace=workspace)
        session.add(vuln)
        session.commit()

        with open(os.path.join(TEST_DATA,'faraday.png'), 'rb') as file_obj:
            new_file = FaradayUploadedFile(file_obj.read())

        new_attach = File(object_type='vulnerability', object_id=vuln.id, name='Faraday', filename='faraday.png',
                          content=new_file)
        session.add(new_attach)
        session.commit()

        res = test_client.get(self.url(workspace=workspace) + '{0}/attachments/'.format(vuln.id))
        assert res.status_code == 200
        assert new_attach.filename in res.json
        assert 'image/png' in res.json[new_attach.filename]['content_type']


    def test_create_vuln_props(self, host_with_hostnames, test_client, session):
        """
        This one should check all the vuln props that don't have a specific case
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        vuln_props = {
            'confirmed': False,
            'data': 'hellodata',
            'easeofresolution': Vulnerability.EASE_OF_RESOLUTIONS[0],
            'owned': True,
            'resolution': 'helloresolution',
            'status': 'closed'
        }
        vuln_props_excluded = ['owned']
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
            **vuln_props
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        for prop, value in vuln_props.items():
            if prop not in vuln_props_excluded:
                assert res.json[prop] == value, prop

    def test_create_idempotent(self, host_with_hostnames, test_client, session):
        """
        This test makes sure that creating the same vuln twice doesn't duplicate the entry or has any other collateral effects
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='Vulnerability name goes here',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='Description goes here',
            severity='critical',
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 409
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()

    def test_create_vuln_with_closed_status(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            status='closed',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['status'] == 'closed'
        assert res.json['name'] == 'New vulns'
        assert res.json['type'] == 'Vulnerability'
        assert res.json['parent'] == host_with_hostnames.id
        assert res.json['parent_type'] == 'Host'

    def _create_put_data(self,
                         name, desc, status, parent, parent_type,
                         attachments=None, impact=None, refs=None,
                         policy_violations=None):
        if not refs:
            refs = []
        if not policy_violations:
            policy_violations = []

        if not impact:
            impact = {"accountability": False, "availability": False, "confidentiality": False, "integrity": False}

        raw_data = {
            "_id":"e1b45f5375facfb1435d37e182ebc22de5f77bb3.e05df1c85617fffb575d2ced2679e9a0ebda7c3e",
            "metadata":{
                "update_time":1509045001.279,
                "update_user":"",
                "update_action":0,
                "creator":"UI Web",
                "create_time":1509045001.279,
                "update_controller_action":
                    "UI Web New",
                "owner":""},
            "obj_id":"e05df1c85617fffb575d2ced2679e9a0ebda7c3e",
            "owner":"",
            "parent": parent,
            "type":"Vulnerability",
            "ws":"cloud",
            "confirmed": True,
            "data":"",
            "desc": desc,
            "easeofresolution":None,
            "impact": impact,
            "name": name,
            "owned": False,
            "policyviolations":policy_violations,
            "refs": refs,
            "resolution":"",
            "severity": "critical",
            "status": status,
            "_attachments":{},
            "description":"",
            "parent_type": parent_type,
            "protocol":"",
            "version":""}

        if attachments:
            raw_data['_attachments'] = {}
            for attachment in attachments:
                raw_data['_attachments'][attachment.name] = {
                     "content_type": "application/x-shellscript",
                     "data": b64encode(attachment.read())
                 }

        return raw_data

    def test_update_vuln_from_open_to_close(self, test_client, session, host_with_hostnames):
        vuln = self.factory.create(status='open', host=host_with_hostnames, service=None, workspace=host_with_hostnames.workspace)
        session.commit()
        raw_data = self._create_put_data(
            name='New name',
            desc='New desc',
            status='closed',
            parent=vuln.host.id,
            parent_type='Host',
            refs=['ref1'],
            policy_violations=['pv0']
        )
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.put(self.url(vuln), data=raw_data)
        assert res.status_code == 200
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert res.json['status'] == 'closed'
        assert res.json['name'] == 'New name'
        assert res.json['desc'] == 'New desc'

    def test_update_vuln_from_correct_type_to_incorrect(self, test_client, session, host_with_hostnames):
        vuln = self.factory.create(status='open', host=host_with_hostnames, service=None, workspace=host_with_hostnames.workspace)
        session.commit()
        raw_data = self._create_put_data(
            name='New name',
            desc='New desc',
            status='open',
            parent=vuln.host.id,
            parent_type='Host',
            refs=['ref1'],
            policy_violations=['pv0']
        )
        raw_data['type'] = "ASDADADASD"
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.put(self.url(vuln), data=raw_data)
        assert res.status_code in [400,409]
        assert vuln_count_previous == session.query(Vulnerability).count()

    def test_create_vuln_web(self, host_with_hostnames, test_client, session):
        service = ServiceFactory.create(host=host_with_hostnames, workspace=host_with_hostnames.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        vuln_web_count_previous = session.query(VulnerabilityWeb).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_web_count_previous + 1 == session.query(VulnerabilityWeb).count()
        assert vuln_count_previous  == session.query(Vulnerability).count()
        assert res.json['name'] == 'New vulns'
        assert res.json['owner'] == 'test'
        assert res.json['type'] == 'VulnerabilityWeb'
        assert res.json['parent'] == service.id
        assert res.json['parent_type'] == 'Service'
        assert res.json['method'] == 'GET'
        assert res.json['path'] == '/pepep'



    @pytest.mark.parametrize('param_name', ['query', 'query_string'])
    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_querystring(
            self, test_client, session, second_workspace,
            vulnerability_web_factory, param_name):
        # VulnerabilityFilterSet has duplicate fields with the same function.
        # This was designed to maintain backwards compatibility

        VulnerabilityGeneric.query.delete()

        # Vulns that shouldn't be shown
        not_expected = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, query_string='aaa')

        # Vulns that must be shown
        expected_vulns = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, query_string='bbb')
        session.add_all(not_expected)
        session.add_all(expected_vulns)
        session.commit()
        expected_ids = {vuln.id for vuln in expected_vulns}

        res = test_client.get(
            self.url(workspace=second_workspace) + f'?{param_name}=bbb')
        assert res.status_code == 200

        for vuln in res.json['data']:
            assert vuln['query'] == 'bbb'
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids


    @pytest.mark.usefixtures('mock_envelope_list')
    @pytest.mark.parametrize('medium_name', ['medium', 'med'])
    def test_filter_by_severity(self, test_client, session,
                                second_workspace,
                                vulnerability_factory,
                                vulnerability_web_factory,
                                medium_name,
                                ):
        expected_ids = set()

        vulns = vulnerability_factory.create_batch(
            5, workspace=second_workspace, severity='high')
        vulns += vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, severity='high')

        medium_vulns = vulnerability_factory.create_batch(
            5, workspace=second_workspace, severity='medium')
        medium_vulns_web = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, severity='medium')
        session.add_all(vulns)
        session.add_all(medium_vulns + medium_vulns_web)
        session.commit()
        expected_ids.update(vuln.id for vuln in medium_vulns)
        expected_ids.update(vuln.id for vuln in medium_vulns_web)

        res = test_client.get(self.url(
            workspace=second_workspace) + '?severity=%s' % medium_name)
        assert res.status_code == 200
        for vuln in res.json['data']:
            assert vuln['severity'] == 'med'
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

    def test_filter_by_invalid_severity_fails(self, test_client):
        res = test_client.get(self.url() + '?severity=131231')
        assert res.status_code == 400
        assert b'Invalid severity type' in res.data

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_invalid_severity(self, test_client):
        res = test_client.get(self.url() + '?severity=invalid')
        assert res.status_code == 400

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_method(self, test_client, session, second_workspace,
                              vulnerability_factory,
                              vulnerability_web_factory):

        # Vulns that shouldn't be shown
        vuln_second_workspace = vulnerability_factory.create_batch(5, workspace=second_workspace)
        more_vuln_second_workspace = vulnerability_web_factory.create_batch(5, workspace=second_workspace,
                                               method='POSTT')

        # Vulns that must be shown
        expected_vulns = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, method='POST')

        session.add_all(vuln_second_workspace)
        session.add_all(more_vuln_second_workspace)
        session.add_all(expected_vulns)
        session.commit()
        expected_ids = {vuln.id for vuln in expected_vulns}

        # This shouldn't show any vulns with POSTT method
        res = test_client.get(self.url(
            workspace=second_workspace) + '?method=POST')
        assert res.status_code == 200
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids, "This may fail because no presence of " \
                                                                              "filter_alchemy branch"

        # This shouldn't show any vulns since by default method filter is
        # an exact match, not a like statement
        res = test_client.get(self.url(
            workspace=second_workspace) + '?method=%25POST%25')
        assert res.status_code == 200
        assert len(res.json['data']) == 0

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_website(self, test_client, session,
                               second_workspace,
                               vulnerability_factory,
                               vulnerability_web_factory,
                               ):

        # Vulns that shouldn't be shown
        second_workspace_vulns = vulnerability_factory.create_batch(5, workspace=second_workspace)
        second_workspace_more_vulns = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, website='other.com')

        # Vulns that must be shown
        expected_vulns = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, website='faradaysec.com')
        session.add_all(second_workspace_vulns)
        session.add_all(second_workspace_more_vulns)
        session.add_all(expected_vulns)
        session.commit()
        expected_ids = {vuln.id for vuln in expected_vulns}

        res = test_client.get(self.url(
            workspace=second_workspace) + '?website=faradaysec.com')
        assert res.status_code == 200

        for vuln in res.json['data']:
            assert vuln['website'] == 'faradaysec.com'
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_target(self, test_client, session, host_factory,
                              service_factory, vulnerability_factory,
                              vulnerability_web_factory):
        host = host_factory.create(workspace=self.workspace,
                                   ip='9.9.9.9')
        expected_ids = set()

        host_vulns = vulnerability_factory.create_batch(
            10, workspace=self.workspace, host=host, service=None)
        session.flush()
        expected_ids.update(v.id for v in host_vulns)

        for service in service_factory.create_batch(10,
                                                    workspace=self.workspace,
                                                    host=host):
            service_vuln = vulnerability_factory.create(
                workspace=self.workspace, service=service, host=None)
            web_vuln = vulnerability_web_factory.create(
                workspace=self.workspace, service=service)
            session.flush()
            expected_ids.add(service_vuln.id)
            expected_ids.add(web_vuln.id)

        res = test_client.get(self.url() + '?target=9.9.9.9')
        assert res.status_code == 200
        for vuln in res.json['data']:
            assert vuln['target'] == '9.9.9.9'
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_sort_by_method(self, session, test_client, second_workspace,
                            vulnerability_factory, vulnerability_web_factory):
        vulns = vulnerability_factory.create_batch(
            10, workspace=second_workspace
        )
        vulns += vulnerability_web_factory.create_batch(
            10, workspace=second_workspace, method=None
        )
        session.add_all(vulns)
        session.commit()
        for method in ('afjbeidcgh'):
            vulnerability_web_factory.create(workspace=second_workspace,
                                             method=method)

        session.commit()
        res = test_client.get(self.url(workspace=second_workspace) +
                              '?sort=method&sort_dir=asc')
        assert res.status_code == 200, res.data
        assert len(res.json['data']) == 30
        assert ''.join(v['method'] for v in res.json['data']
                       if v['method']) == 'abcdefghij'

        res = test_client.get(self.url(workspace=second_workspace) +
                              '?sort=method&sort_dir=desc')
        assert res.status_code == 200, res.data
        assert len(res.json['data']) == 30
        assert ''.join(v['method'] for v in res.json['data']
                       if v['method']) == 'abcdefghij'[::-1]

    def test_create_vuln_with_evidence(self, host_with_hostnames, test_client,
                                       session):
        session.commit()  # flush host_with_hostnames
        attachments = [
            open(os.path.join(CURRENT_PATH, 'data', 'faraday.png'), 'rb'),
            open(os.path.join(CURRENT_PATH, 'data', 'test.html'), 'rb')
        ]
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            attachments=attachments,
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)

        assert res.status_code == 201
        assert len(res.json['_attachments']) == 2
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        [fileobj.close() for fileobj in attachments]

    def test_create_vuln_with_refs(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=['CVE-2017-0002', 'CVE-2017-0012', 'CVE-2017-0012'],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert session.query(Reference).count() == 2
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()

    def test_create_vuln_with_policyviolations(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=['PCI DSS Credir card not encrypted',
                              'PCI DSS Credir card not encrypted'],
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert session.query(PolicyViolation).count() == 1
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()

    def test_create_vuln_imapct_verification(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            impact={
                'accountability': True,
                'availability': True,
                'confidentiality': True,
                'integrity': True
            }
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['name'] == 'New vulns'
        assert res.json['impact'] == {u'accountability': True,
                                     u'availability': True,
                                     u'confidentiality': True,
                                     u'integrity': True}

    def test_handles_invalid_impact(self, host_with_hostnames, test_client,
                                    session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            impact={
                'accountability': True,
                'integrity': 'aaaa',
                'invalid': None,
            }
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400

    def test_create_vuln_with_invalid_type(self,
                                           host_with_hostnames,
                                           test_client,
                                           session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='VulnerabilitySarasa',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post(
            '/v2/ws/{0}/vulns/'.format(ws_name),
            data=raw_data,
        )
        assert res.status_code == 400
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert res.json['message'] == 'Invalid vulnerability type.'

    def test_create_vuln_without_type(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='a',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        raw_data.pop("type")
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert res.json['message'] == 'Type is required.'

    def test_create_vuln_with_invalid_severity(self,
                                               host_with_hostnames,
                                               test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            severity="invalid",
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert b'Invalid severity type.' in res.data

    def test_create_vuln_with_invalid_ease_of_resolution(self,
                                                         host_with_hostnames,
                                                         test_client,
                                                         session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            easeofresolution='frutafrutafruta'
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert list(res.json['messages']['json'].keys()) == ['easeofresolution']
        assert 'Must be one of' in res.json['messages']['json']['easeofresolution'][0]

    def test_create_vuln_with_null_ease_of_resolution(self,
                                                      host_with_hostnames,
                                                      test_client,
                                                      session):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            easeofresolution=None,
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code == 201, (res.status_code, res.data)
        created_vuln = Vulnerability.query.get(res.json['_id'])
        assert created_vuln.ease_of_resolution is None


    def test_count_order_by_incorrect_keyword(self, test_client, session):
        for i, vuln in enumerate(self.objects[:3]):
            vuln.confirmed = True
            # Set critical severity to first vuln, high to the others
            if i == 0:
                vuln.severity = 'critical'
            else:
                vuln.severity = 'high'

            session.add(vuln)
            session.commit()

        #Desc
        res = test_client.get(self.url() +
                              "count/?confirmed=1&group_by=severity&order=sc")
        assert res.status_code == 400

        #Asc
        res = test_client.get(self.url() +
                              "count/?confirmed=1&group_by=severity&order=name,asc")
        assert res.status_code == 400


    def test_count_order_by(self, test_client, session):
        for i, vuln in enumerate(self.objects[:3]):
            vuln.confirmed = True
            # Set critical severity to first vuln, high to the others
            if i == 0:
                vuln.severity = 'critical'
            else:
                vuln.severity = 'high'

            session.add(vuln)
            session.commit()

        #Desc
        res = test_client.get(self.url() +
                              "count/?confirmed=1&group_by=severity&order=desc")
        assert res.status_code == 200
        assert res.json['total_count'] == 3
        assert sorted(res.json['groups'], key=lambda i: (i['name'],i['count'],i['severity'])) == sorted([
            {"name": "high", "severity": "high", "count": 2},
            {"name": "critical", "severity": "critical", "count": 1},
        ], key=lambda i: (i['name'],i['count'],i['severity']))

        #Asc
        res = test_client.get(self.url() +
                              "count/?confirmed=1&group_by=severity&order=asc")
        assert res.status_code == 200
        assert res.json['total_count'] == 3
        assert sorted(res.json['groups'], key=lambda i: (i['name'],i['count'],i['severity']), reverse=True) == sorted([
            {"name": "critical", "severity": "critical", "count": 1},
            {"name": "high", "severity": "high", "count": 2},
        ], key=lambda i: (i['name'],i['count'],i['severity']), reverse=True)


    def test_count_group_by_incorrect_vuln_column(self, test_client, session):
        for i, vuln in enumerate(self.objects[:3]):
            vuln.confirmed = True
            # Set critical severity to first vuln, high to the others
            if i == 0:
                vuln.severity = 'critical'
            else:
                vuln.severity = 'high'

            session.add(vuln)
            session.commit()

        res = test_client.get(self.url() +
                              "count/?confirmed=1&group_by=username")
        assert res.status_code == 400

        res = test_client.get(self.url() +
                              "count/?confirmed=1&group_by=")
        assert res.status_code == 400



    def test_count_confirmed(self, test_client, session):
        for i, vuln in enumerate(self.objects[:3]):
            vuln.confirmed = True

            # Set critical severity to first vuln, high to the others
            if i == 0:
                vuln.severity = 'critical'
            else:
                vuln.severity = 'high'

            session.add(vuln)
            session.commit()

        res = test_client.get(self.url() +
                              'count/?confirmed=1&group_by=severity')
        assert res.status_code == 200
        assert res.json['total_count'] == 3
        assert sorted(res.json['groups'], key=lambda i: (i['count'],i['name'],i['severity'])) == sorted([
            {"name": "high", "severity": "high", "count": 2},
            {"name": "critical", "severity": "critical", "count": 1},
        ], key=lambda i: (i['count'],i['name'],i['severity']))

    def test_count_severity_map(self, test_client, second_workspace, session):
        vulns = self.factory.create_batch(4, severity='informational',
                                  workspace=second_workspace)
        vulns += self.factory.create_batch(3, severity='medium',
                                  workspace=second_workspace)
        vulns += self.factory.create_batch(2, severity='low',
                                  workspace=second_workspace)
        session.add_all(vulns)
        session.commit()

        res = test_client.get(self.url(workspace=second_workspace) +
                              'count/?group_by=severity')
        assert res.status_code == 200
        assert res.json['total_count'] == 9
        assert sorted(res.json['groups'], key=lambda i: (i['count'],i['name'],i['severity'])) == sorted([
            {"name": "med", "severity": "med", "count": 3},
            {"name": "low", "severity": "low", "count": 2},
            {"name": "info", "severity": "info", "count": 4},
        ], key=lambda i: (i['count'],i['name'],i['severity']))

    def test_count_multiworkspace_one_workspace(self, test_client, session):
        for i, vuln in enumerate(self.objects):
            vuln.confirmed = True
            # Set critical severity to first vuln, high to the others
            if i == 0:
                vuln.severity = 'critical'
            else:
                vuln.severity = 'high'

            session.add(vuln)
            session.commit()

        res = test_client.get(f'{self.url()}'
                              f'count_multi_workspace/?workspaces='
                              f'{self.workspace.name}'
                              f'&confirmed=1&group_by=severity&order=desc')

        assert res.status_code == 200
        assert len(res.json['groups']) == 1
        assert res.json['total_count'] == 5


    def test_count_multiworkspace_two_public_workspaces(self, test_client, session, second_workspace):
        vulns = self.factory.create_batch(1, severity='informational',
                                  workspace=second_workspace)
        vulns += self.factory.create_batch(3, severity='medium',
                                  workspace=second_workspace)
        vulns += self.factory.create_batch(1, severity='low',
                                  workspace=second_workspace)
        session.add_all(vulns)
        session.commit()

        for i, vuln in enumerate(self.objects):
            vuln.confirmed = True
            # Set critical severity to first vuln, high to the others
            if i == 0:
                vuln.severity = 'critical'
            else:
                vuln.severity = 'high'

            session.add(vuln)
        session.commit()

        res = test_client.get(f'{self.url()}'
                              f'count_multi_workspace/?workspaces='
                              f'{self.workspace.name}'
                              f','
                              f'{second_workspace.name}'
                              f'&confirmed=1&group_by=severity&order=desc')

        assert res.status_code == 200
        assert len(res.json['groups']) == 2
        assert res.json['total_count'] == 10

    def test_count_multiworkspace_no_workspace_param(self, test_client):
        res = test_client.get(f'{self.url()}count_multi_workspace/?confirmed=1&group_by=severity&order=desc')
        assert res.status_code == 400

    def test_count_multiworkspace_no_groupby_param(self, test_client):
        res = test_client.get(f'{self.url()}count_multi_workspace/?workspaces={self.workspace.name}&confirmed=1&order=desc')
        assert res.status_code == 400

    def test_count_multiworkspace_nonexistent_ws(self, test_client):
        res = test_client.get(f'{self.url()}count_multi_workspace/?workspaces=asdf,{self.workspace.name}&confirmed=1&group_by=severity&order=desc')
        assert res.status_code == 404


    @pytest.mark.usefixtures('mock_envelope_list')
    def test_target(self, test_client, session, second_workspace,
                    host_factory, service_factory,
                    vulnerability_factory, vulnerability_web_factory):
        host_factory.create_batch(5, workspace=second_workspace)
        service_factory.create_batch(5, workspace=second_workspace)
        host = host_factory.create(workspace=second_workspace)
        service = service_factory.create(host=host,
                                         workspace=second_workspace)
        vulns = [
            vulnerability_factory.create(host=host, service=None,
                                         workspace=second_workspace),
            vulnerability_factory.create(service=service, host=None,
                                         workspace=second_workspace),
            vulnerability_web_factory.create(service=service,
                                             workspace=second_workspace),
        ]

        session.commit()
        res = test_client.get(self.url(workspace=second_workspace))
        assert res.status_code == 200
        for v in res.json['data']:
            assert v['target'] == host.ip

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_os(self, test_client, session, second_workspace,
                host_factory, service_factory,
                vulnerability_factory, vulnerability_web_factory):
        host_factory.create_batch(5, workspace=second_workspace)
        service_factory.create_batch(5, workspace=second_workspace)
        host = host_factory.create(workspace=second_workspace)
        service = service_factory.create(host=host,
                                         workspace=second_workspace)
        vulns = [
            vulnerability_factory.create(host=host, service=None,
                                         workspace=second_workspace),
            vulnerability_factory.create(service=service, host=None,
                                         workspace=second_workspace),
            vulnerability_web_factory.create(service=service,
                                             workspace=second_workspace),
        ]

        session.commit()
        res = test_client.get(self.url(workspace=second_workspace))
        assert res.status_code == 200
        for v in res.json['data']:
            assert v['host_os'] == host.os

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_command_id(self, test_client, session,
                                  second_workspace,
                                  workspace,
                                  vulnerability_factory,
                                  vulnerability_web_factory,
                                  ):
        expected_ids = set()
        web_expected_ids = set()
        host = HostFactory.create(workspace=second_workspace)
        service = ServiceFactory.create(workspace=second_workspace)

        command = EmptyCommandFactory.create(workspace=second_workspace)
        web_command = EmptyCommandFactory.create(workspace=second_workspace)
        high_vulns = vulnerability_factory.create_batch(
            5, workspace=second_workspace, severity='high', host=host, service=None)
        high_vulns_web = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, severity='high', service=service)
        session.commit()
        CommandObjectFactory.create(
            command=command,
            object_type='host',
            object_id=host.id,
            workspace=second_workspace
        )
        CommandObjectFactory.create(
            command=web_command,
            object_type='service',
            object_id=service.id,
            workspace=second_workspace
        )
        for high_vuln in high_vulns:

            CommandObjectFactory.create(
                command=command,
                object_type='vulnerability',
                object_id=high_vuln.id,
                workspace=second_workspace
            )
        for high_vuln_web in high_vulns_web:

            CommandObjectFactory.create(
                command=web_command,
                object_type='vulnerability',
                object_id=high_vuln_web.id,
                workspace=second_workspace
            )

        session.commit()

        expected_ids.update(vuln.id for vuln in high_vulns)
        web_expected_ids.update(vuln.id for vuln in high_vulns_web)

        res = test_client.get(self.url(
            workspace=second_workspace) + '?command_id={0}'.format(command.id))
        assert res.status_code == 200
        for vuln in res.json['data']:
            command_object = CommandObject.query.filter_by(
                object_id=vuln['_id'],
                object_type='vulnerability',
                workspace=second_workspace,
            ).first()
            vuln['metadata']['command_id'] == command_object.command.id
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

        # Check for web vulns
        res = test_client.get(self.url(
            workspace=second_workspace) + '?command_id={0}'.format(web_command.id))
        assert res.status_code == 200
        for vuln in res.json['data']:
            command_object = CommandObject.query.filter_by(
                object_id=vuln['_id'],
                object_type='vulnerability',
                workspace=second_workspace,
            ).first()
            vuln['metadata']['command_id'] == command_object.command.id
        assert set(vuln['_id'] for vuln in res.json['data']) == web_expected_ids

        # Check for cross-workspace bugs
        res = test_client.get(self.url(
            workspace=workspace) + '?command_id={0}'.format(web_command.id))
        assert res.status_code == 200
        assert len(res.json['data']) == 0

    def test_vulnerability_metadata(self, session, test_client, workspace):
        owner = UserFactory.create()
        service = ServiceFactory.create(workspace=workspace)
        command = EmptyCommandFactory.create(id=5555, workspace=workspace)
        update_command = EmptyCommandFactory.create(workspace=workspace)

        vuln = VulnerabilityWebFactory.create(
            service=service,
            creator=owner,
            workspace=workspace,
        )
        session.flush()
        CommandObjectFactory.create(
            command=command,
            object_type='vulnerability',
            object_id=vuln.id,
            workspace=workspace
        )

        CommandObjectFactory.create(
            command=update_command,
            object_type='vulnerability',
            object_id=vuln.id,
            workspace=workspace
        )
        session.commit()

        res = test_client.get(self.url())
        assert res.status_code == 200
        from_json_vuln = list(filter(lambda raw_vuln: raw_vuln['id'] == vuln.id,
                                res.json['vulnerabilities']))
        assert 'metadata' in from_json_vuln[0]['value']
        expected_metadata = {
            u'command_id': command.id,
            u'create_time': pytz.UTC.localize(vuln.create_date).isoformat(),
            u'creator': command.tool,
            u'owner': owner.username,
            u'update_action': 0,
            u'update_controller_action': u'',
            u'update_time': pytz.UTC.localize(vuln.update_date).isoformat(),
            u'update_user': None
        }
        assert expected_metadata == from_json_vuln[0]['value']['metadata']

    @pytest.mark.parametrize("parent_type, parent_factory", [
        ("Host", HostFactory),
        ("Service", ServiceFactory),
    ], ids=["with host parent", "with service parent"])
    def test_create_with_parent_of_other_workspace(
            self, parent_type, parent_factory, test_client, session,
            second_workspace):
        parent = parent_factory.create(workspace=second_workspace)
        session.commit()
        assert parent.workspace_id != self.workspace.id
        data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=parent.id,
            parent_type=parent_type,
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        res = test_client.post(self.url(), data=data)
        assert res.status_code == 400
        assert b'Parent id not found' in res.data

    @pytest.mark.parametrize("parent_type, parent_factory", [
        ("Host", HostFactory),
        ("Service", ServiceFactory),
    ], ids=["with host parent", "with service parent"])
    def test_update_with_parent_of_other_workspace(
            self, parent_type, parent_factory, test_client, session,
            second_workspace, credential_factory):
        parent = parent_factory.create(workspace=second_workspace)
        session.add(parent)
        session.commit()
        assert parent.workspace_id != self.workspace.id
        data = self._create_put_data(
            name='New name',
            desc='New desc',
            status='closed',
            parent=parent.id,
            parent_type=parent_type,
            refs=['ref1'],
            policy_violations=['pv0']
        )
        res = test_client.put(self.url(self.first_object), data=data)
        assert res.status_code == 400
        assert b'Parent id not found' in res.data

    def test_create_vuln_multiple_times_returns_conflict(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code == 409

    def test_create_webvuln_multiple_times_returns_conflict(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        service = ServiceFactory.create(workspace=self.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code == 409

    def test_create_similar_vuln_service_and_vuln_web_conflict_succeed(
            self, service, vulnerability_factory, vulnerability_web_factory,
            session, test_client, workspace):
        service_vuln = vulnerability_factory.create(
            service=service, host=None, workspace=workspace,
            name="test conflict", description="test"
        )
        session.commit()
        old_count = VulnerabilityGeneric.query.count()
        raw_data = _create_post_data_vulnerability(
            name='test conflict',
            description='test',
            vuln_type='Vulnerability',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            severity='low',
        )
        raw_data['type'] = 'VulnerabilityWeb'
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 201
        assert VulnerabilityGeneric.query.count() == old_count + 1

    def test_update_conflict(self, host, vulnerability_factory, session,
                             test_client):
        vulnerability_factory.create(
            workspace=self.workspace, host=host, service=None,
            name="x", description="x")
        target_vuln = vulnerability_factory.create(
            workspace=self.workspace, host=host, service=None,
            name="y", description="y")
        session.commit()
        raw_data = self._create_put_data(
            'x',
            'x',
            'open',
            host.id,
            'Host',
        )
        res = test_client.put(self.url(obj=target_vuln), data=raw_data)
        assert res.status_code == 409, res.json

    def test_create_and_update_webvuln(self, host_with_hostnames, test_client, session):
        """
            This reproduces a bug found. after creating an object with a
            command, the update caused an integrity error within the same
            command scope.
        """
        command = CommandFactory.create(workspace=self.workspace)
        service = ServiceFactory.create(workspace=self.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/?command_id={1}'.format(ws_name, command.id), data=raw_data)
        assert res.status_code == 201
        raw_data = _create_post_data_vulnerability(
            name='Update vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='Update helloworld',
            severity='high',
        )
        res = test_client.put('/v2/ws/{0}/vulns/{1}/?command_id={2}'.format(ws_name, res.json['_id'], command.id),
                              data=raw_data)
        assert res.status_code == 200


    def test_create_vuln_from_command(self, test_client, session):
        command = EmptyCommandFactory.create(workspace=self.workspace)
        service = ServiceFactory.create(workspace=self.workspace)
        session.commit()
        assert len(command.command_objects) == 0
        url = self.url(workspace=command.workspace) + '?' + urlencode({'command_id': command.id})
        raw_data = _create_post_data_vulnerability(
            name='Update vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='high',
        )
        res = test_client.post(url, data=raw_data)

        assert res.status_code == 201
        assert len(command.command_objects) == 1
        cmd_obj = command.command_objects[0]
        assert cmd_obj.object_type == 'vulnerability'
        assert cmd_obj.object_id == res.json['_id']
        assert res.json['metadata']['creator'] == command.tool

    def test_with_invalid_id_returns_400(self, session, test_client):
        """
            Bug found on hackaton.
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id='',
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 400

    def test_vuln_created_without_command_has_webui_in_metadata(self, test_client, session):
        host = HostFactory.create(workspace=self.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 201
        assert res.json['metadata']['creator'] == 'Web UI'

    def test_invalid_host_id_error_message(self, test_client):
        """
            This test reporduces a bug when the parent_id is a string it returned
            the error message "Invalid Parent Type"
        """
        raw_data = {
            'command_id': None,
             'confirmed': False,
             'data': None,
             'desc': 'pepe',
             'description': 'pepe',
             'metadata': {
                'command_id': '',
                'create_time': 1518627247.194113,
                'creator': '',
                'owner': '',
                'update_action': 0,
                'update_controller_action': 'No model controller call',
                'update_time': 1518627247.194114,
                'update_user': ''},
             'name': 'vuln1',
             'owned': False,
             'owner': '',
             'parent': '358302',
             'parent_type': 'Host',
             'policyviolations': [],
             'refs': [],
             'resolution': '',
             'severity': 'critical',
             'status': 'opened',
             'type': 'Vulnerability'
        }

        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 400
        assert res.json == {u'messages': {'json': {u'_schema': [u'Parent id not found: 358302']}}}

    def test_after_deleting_vuln_ref_and_policies_remains(self, session, test_client):
        vuln = VulnerabilityFactory.create(workspace=self.workspace)
        ref1 = ReferenceFactory.create(workspace=self.workspace)
        pv1 = PolicyViolationFactory.create(workspace=self.workspace)
        vuln.reference_instances.add(ref1)
        vuln.policy_violation_instances.add(pv1)
        session.add(vuln)
        session.commit()

        assert Reference.query.count() == 1
        assert PolicyViolation.query.count() == 1
        assert Vulnerability.query.count() == 6

        res = test_client.delete(self.url(vuln))

        assert res.status_code == 204

        assert Reference.query.count() == 1
        assert PolicyViolation.query.count() == 1
        assert Vulnerability.query.count() == 5

    def test_search_by_id(self, session, test_client):
        vuln = VulnerabilityFactory.create()
        vuln2 = VulnerabilityFactory.create(workspace=vuln.workspace)
        session.add(vuln)
        session.add(vuln2)
        session.commit()
        res = test_client.get(self.url(workspace=vuln.workspace) + '?id={0}'.format(vuln.id))
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['value']['name'] == vuln.name

    def test_search_by_hostnames_service_case(self, session, test_client):
        workspace = WorkspaceFactory.create()
        vuln2 = VulnerabilityFactory.create(workspace=workspace)
        hostname = HostnameFactory.create(workspace=workspace, name='test.com')
        host = HostFactory.create(workspace=workspace)
        host.hostnames.append(hostname)
        service = ServiceFactory.create(workspace=workspace, host=host)
        vuln = VulnerabilityFactory.create(service=service, host=None, workspace=workspace)
        session.add(vuln)
        session.add(vuln2)
        session.add(service)
        session.add(hostname)
        session.commit()
        url = self.url(workspace=workspace) + '?hostnames={0}'.format(hostname.name)
        res = test_client.get(url)

        assert res.status_code == 200
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['value']['name'] == vuln.name

    def test_search_by_hostnames_host_case(self, session, test_client):
        workspace = WorkspaceFactory.create()
        vuln2 = VulnerabilityFactory.create(workspace=workspace)
        hostname = HostnameFactory.create(workspace=workspace, name='test.com')
        host = HostFactory.create(workspace=workspace)
        host.hostnames.append(hostname)
        vuln = VulnerabilityFactory.create(host=host, service=None, workspace=workspace)
        session.add(vuln)
        session.add(vuln2)
        session.add(host)
        session.add(hostname)
        session.commit()
        url = self.url(workspace=workspace) + '?hostnames={0}'.format(hostname.name)
        res = test_client.get(url)
        assert res.status_code == 200
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['value']['name'] == vuln.name

    def test_hostnames_comma_separated(self, test_client, session):
        #Create Host A with hostname HA
        hostnameA = HostnameFactory.create()
        hostnameA.host.workspace = hostnameA.workspace
        #Create Host B with hostname HB
        hostnameB = HostnameFactory.create(workspace=hostnameA.workspace)
        hostnameB.host.workspace = hostnameA.workspace
        #Create Vuln with Host A
        vuln = VulnerabilityFactory.create(host=hostnameA.host, workspace=hostnameA.workspace)
        #Create Vuln with Host B
        vuln2 = VulnerabilityFactory.create(host=hostnameB.host, workspace=hostnameA.workspace)
        session.add(hostnameA)
        session.add(hostnameB)
        session.add(vuln)
        session.add(vuln2)
        session.commit()

        #Search with hosnames=HA,HB
        res = test_client.get(self.url(workspace=vuln.workspace) + '?hostname={0},{1}'.format(hostnameA,hostnameB))
        assert res.status_code == 200
        assert res.json['count'] == 2

    def test_missing_policy_violation_case(self, test_client, session):
        """
            bug found when a json was missing the policyviolations key
        """
        host = HostFactory.create(workspace=self.workspace)
        session.commit()
        data = {
             'name': 'Test Alert policy_violations',
             'severity': 'informational',
             'creator': 'Zap',
             'parent_type': 'Host',
             'parent': host.id,
             'type': 'Vulnerability',
        }
        res = test_client.post(self.url(), data=data)
        assert res.status_code == 201

    def test_missing_references_case(self, test_client, session):
        """
            bug found when a json was missing the policyviolations key
        """
        host = HostFactory.create(workspace=self.workspace)
        session.commit()
        data = {
             'name': 'Test Alert policy_violations',
             'severity': 'informational',
             'creator': 'Zap',
             'parent_type': 'Host',
             'parent': host.id,
             'type': 'Vulnerability',
        }
        res = test_client.post(self.url(), data=data)
        assert res.status_code == 201

    def test_add_attachment_to_vuln(self, test_client, session, csrf_token,
                                    host_with_hostnames):
        ws = WorkspaceFactory.create(name='abc')
        session.add(ws)
        vuln = VulnerabilityFactory.create(workspace=ws)
        session.add(vuln)
        session.commit()
        file_contents = b'my file contents'
        data = {
            'file' : (BytesIO(file_contents), 'borrar.txt')
        }
        headers = {'Content-type': 'multipart/form-data'}

        res = test_client.post(
            '/v2/ws/abc/vulns/{0}/attachment/'.format(vuln.id),
            data=data, headers=headers, use_json_data=False)
        assert res.status_code == 403  # Missing CSRF protection

        data = {
            'file' : (BytesIO(file_contents), 'borrar.txt'),
            'csrf_token': csrf_token
        }
        res = test_client.post(
            '/v2/ws/abc/vulns/{0}/attachment/'.format(vuln.id),
            data=data, headers=headers, use_json_data=False)
        assert res.status_code == 200  # Now it should work

        file_id = session.query(Vulnerability).filter_by(id=vuln.id).first().evidence[0].content['file_id']
        depot = DepotManager.get()
        assert file_contents == depot.get(file_id).read()

    def test_add_attachment_to_vuln_fails_readonly(self, test_client, session, host_with_hostnames):
        ws = WorkspaceFactory.create(name='abc')
        session.add(ws)
        vuln = VulnerabilityFactory.create(workspace=ws)
        session.add(vuln)
        session.commit()
        file_contents = b'my file contents'
        data = {
            'file' : (BytesIO(file_contents), 'borrar.txt')
        }
        headers = {'Content-type': 'multipart/form-data'}

        ws.readonly = True
        session.commit()

        res = test_client.post(
            '/v2/ws/abc/vulns/{0}/attachment/'.format(vuln.id),
            data=data, headers=headers, use_json_data=False)
        assert res.status_code == 403
        query_test = session.query(Vulnerability).filter_by(id=vuln.id).first().evidence
        assert query_test == []

    def test_delete_attachment_from_vuln(self, test_client, session, host_with_hostnames):
        session.commit() # flush host_with_hostnames
        ws_name = host_with_hostnames.workspace.name
        attachment = NamedTemporaryFile()
        file_content = b'test file'
        attachment.write(file_content)
        attachment.seek(0)
        vuln = _create_post_data_vulnerability(
            name='Testing vuln',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            attachments=[attachment]
        )
        res = test_client.post('/v2/ws/{workspace}/vulns/'\
            .format(workspace=ws_name), data=vuln)
        assert res.status_code == 201

        filename = attachment.name.split('/')[-1]
        vuln_id = res.json['_id']
        res = test_client.delete(
            '/v2/ws/{workspace}/vulns/{vulnerability}/attachment/{file_name}/'
                .format(workspace=ws_name, vulnerability=vuln_id, file_name=filename)
        )
        assert res.status_code == 200

        query_test = session.query(Vulnerability).filter_by(id=vuln_id).first().evidence
        assert query_test == []

    def test_delete_attachment_from_vuln_fails_readonly(self, test_client, session, host_with_hostnames):
        session.commit() # flush host_with_hostnames
        ws_name = host_with_hostnames.workspace.name
        attachment = NamedTemporaryFile()
        file_content = b'test file'
        attachment.write(file_content)
        attachment.seek(0)
        vuln = _create_post_data_vulnerability(
            name='Testing vuln',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            attachments=[attachment]
        )
        res = test_client.post('/v2/ws/{workspace}/vulns/'\
            .format(workspace=ws_name), data=vuln)
        assert res.status_code == 201

        self.workspace.readonly = True
        session.commit()

        filename = attachment.name.split('/')[-1]
        vuln_id = res.json['_id']
        res = test_client.delete(
            '/v2/ws/{workspace}/vulns/{vulnerability}/attachment/{file_name}/'
                .format(workspace=ws_name, vulnerability=vuln_id, file_name=filename)
        )
        assert res.status_code == 403

        query_test = session.query(Vulnerability).filter_by(id=vuln_id).first().evidence
        assert len(query_test) == 1
        assert query_test[0].filename == filename

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_vuln_filter(self, test_client, session, workspace):
        new_host = HostFactory.create(workspace=workspace)
        session.commit()

        raw_data = _create_post_data_vulnerability(
            name='vuln_1',
            vuln_type='Vulnerability',
            parent_id=new_host.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='medium',
        )
        res = test_client.post('/v2/ws/{workspace}/vulns/'
            .format(workspace=workspace.name), data=raw_data)

        data = {
            'q': '{"filters":[{"name":"severity","op":"eq","val":"medium"}]}'
        }
        res = test_client.get('/v2/ws/{name}/vulns/filter'
            .format(name=workspace.name), query_string=data)

        assert res.status_code == 200

        value = res.json['vulnerabilities'][0]['value']
        assert value['name'] == 'vuln_1'

    def test_invalid_vuln_filters(self, test_client, session, workspace):
        data = {
            "q": {"filters":[{"name":"severity","op":"eq","val":"medium"}]}
        }
        res = test_client.get('/v2/ws/{name}/vulns/filter'.format(name=workspace.name), query_string=data)
        assert res.status_code == 400

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_vuln_filter_exception(self, test_client, workspace, session):
        vuln = VulnerabilityFactory.create(workspace=workspace, severity="medium")
        session.add(vuln)
        session.commit()
        data = {
            'q': '{"filters":[{"name":"severity","op":"eq","val":"medium"}]}'
        }
        res = test_client.get('/v2/ws/{name}/vulns/filter'.format(name=workspace.name), query_string=data)
        assert res.status_code == 200
        assert res.json['count'] == 1

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_vuln_web_filter_exception(self, test_client, workspace, session):
        vuln = VulnerabilityWebFactory.create(workspace=workspace, severity="medium")
        session.add(vuln)
        session.commit()
        data = {
            'q': '{"filters":[{"name":"severity","op":"eq","val":"medium"}]}'
        }
        res = test_client.get('/v2/ws/{name}/vulns/filter'.format(name=workspace.name), query_string=data)
        assert res.status_code == 200
        assert res.json['count'] == 1

    def test_add_vuln_without_parent_id(self, test_client):
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=0,
            parent_type="Host",
            refs=[],
            policyviolations=[],
        )
        with pytest.raises(Exception) as err:
            res = test_client.post(self.url(), data=raw_data)
        assert err.typename in ['AssertionError', 'ValueError']

    def test_add_vuln_with_unknown_parent_type(self, test_client, session, host_with_hostnames):
        session.commit()
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type="invalid_host",
            refs=[],
            policyviolations=[],
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.json['messages']['json']['_schema'][0] == 'Unknown parent type'

    def test_add_empty_attachment(self, test_client, session, workspace, csrf_token):
        vuln = VulnerabilityFactory.create(workspace=workspace)
        session.add(vuln)
        session.commit()

        res = test_client.post(
            '/v2/ws/{ws_name}/vulns/{id}/attachment/'
                .format(ws_name=workspace.name,id=vuln.id),
            data={'csrf_token': csrf_token},
            headers={'Content-Type': 'multipart/form-data'},
            use_json_data=False)
        assert res.status_code == 400

    def test_get_attachment_with_invalid_workspace_and_vuln(self, test_client):
        res = test_client.get(
            '/v2/ws/{ws_name}/vulns/{vuln_id}/attachment/{name}/'
            .format(ws_name="invalid_ws", vuln_id="invalid_vuln", name="random_name"))
        assert res.status_code == 404

    def test_delete_attachment_with_invalid_workspace_and_vuln(self, test_client):
        res = test_client.delete(
            '/v2/ws/{ws_name}/vulns/{vuln_id}/attachment/{name}/'
            .format(ws_name="invalid_ws",vuln_id="invalid_vuln", name="random_name"))
        assert res.status_code == 404

    def test_delete_invalid_attachment(self, test_client, workspace, session):
        vuln = VulnerabilityFactory.create(workspace=workspace)
        session.add(vuln)
        session.commit()
        res = test_client.delete(
            '/v2/ws/{ws_name}/vulns/{vuln_id}/attachment/{name}/'
            .format(ws_name=workspace.name,vuln_id=vuln.id, name="random_name"))
        assert res.status_code == 404

    def test_export_vuln_csv_empty_workspace(self, test_client, session):
        ws = WorkspaceFactory(name='abc')
        res = test_client.get('/v2/ws/{ws_name}/vulns/export_csv/'.format(ws_name=ws.name))
        expected_headers = [
            "confirmed", "id", "date", "name", "severity", "service",
            "target", "desc", "status", "hostnames", "comments", "owner",
            "os", "resolution", "refs", "easeofresolution", "web_vulnerability",
            "data", "website", "path", "status_code", "request", "response", "method",
            "params", "pname", "query", "policyviolations", "external_id", "impact_confidentiality",
            "impact_integrity", "impact_availability", "impact_accountability", "update_date",
            "host_id", "host_description", "mac",
            "host_owned", "host_creator_id", "host_date", "host_update_date",
            "service_id", "service_name", "service_description", "service_owned",
            "port", "protocol", "summary", "version", "service_status",
            "service_creator_id", "service_date", "service_update_date", "service_parent_id"
        ]
        assert res.status_code == 200
        assert expected_headers == res.data.decode('utf-8').strip('\r\n').split(',')

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_export_vuln_csv_filters_confirmed_using_filters_query(self, test_client, session):
        workspace = WorkspaceFactory.create()
        confirmed_vulns = VulnerabilityFactory.create(confirmed=True, workspace=workspace)
        session.add(confirmed_vulns)
        session.commit()
        res = test_client.get(self.url(workspace=workspace) + 'export_csv/?q={"filters":[{"name":"confirmed","op":"==","val":"true"}]}')
        assert res.status_code == 200
        assert self._verify_csv(res.data, confirmed=True)

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_export_vuln_csv_unicode_bug(self, test_client, session):
        workspace = WorkspaceFactory.create()
        desc = u'Latin-1 Supplement \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8'
        confirmed_vulns = VulnerabilityFactory.create(
            confirmed=True,
            description=desc,
            workspace=workspace)
        session.add(confirmed_vulns)
        session.commit()
        res = test_client.get(self.url(workspace=workspace) + 'export_csv/')
        assert res.status_code == 200
        assert self._verify_csv(res.data, confirmed=True)

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_export_vuln_csv_filters_confirmed_using_filters_query_severity(self, test_client, session):
        workspace = WorkspaceFactory.create()
        confirmed_vulns = VulnerabilityFactory.create(confirmed=True, severity='critical', workspace=workspace)
        session.add(confirmed_vulns)
        session.commit()
        res = test_client.get(self.url(workspace=workspace) + 'export_csv/?q={"filters":[{"name":"severity","op":"==","val":"critical"}]}')
        assert res.status_code == 200
        assert self._verify_csv(res.data, confirmed=True, severity='critical')

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_export_vulns_confirmed(self, session, test_client):
        self.first_object.confirmed = True
        session.add(self.first_object)
        session.commit()
        res = test_client.get(self.url() + 'export_csv/?confirmed=true')
        assert res.status_code == 200
        self._verify_csv(res.data, confirmed=True)

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_export_vulns_check_update_time(self, session, test_client):
        workspace = WorkspaceFactory.create()
        host = HostFactory.create(workspace=workspace)
        session.add(host)
        service = ServiceFactory.create(workspace=workspace, host=host)
        session.add(service)
        vuln = VulnerabilityFactory.create(workspace=workspace, host=host)
        vuln.service = service
        session.add(vuln)
        session.commit()

        host.owned = True
        service.owned = True
        vuln.confirmed = True
        session.add(host)
        session.add(service)
        session.add(vuln)
        session.commit()

        res = test_client.get('v2/ws/{}/vulns/export_csv/'.format(workspace.name))
        assert res.status_code == 200

        csv_data = csv.DictReader(StringIO(res.data.decode('utf-8')), delimiter=',')

        for index, line in enumerate(csv_data):
            create_date = parser.parse(line['date'])
            update_date = parser.parse(line['update_date'])
            assert create_date < update_date

            create_date = parser.parse(line['host_date'])
            update_date = parser.parse(line['host_update_date'])
            assert create_date < update_date

            create_date = parser.parse(line['service_date'])
            update_date = parser.parse(line['service_update_date'])
            assert create_date < update_date

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_export_vulns_csv_with_custom_fields(self, session, test_client):

        custom_field_schema = CustomFieldsSchemaFactory(
            field_name='cvss',
            field_type='str',
            field_display_name='CVSS',
            table_name='vulnerability'
        )
        session.add(custom_field_schema)
        session.commit()
        for vuln in self.objects:
            vuln.custom_fields = {"cvss": "9"}

        # lets add a non "schema" custom field called invalid, this should not be shown on the csv
        self.first_object.custom_fields = {"cvss": "9", "invalid": "not shown"}
        # another case witt custom fields as None
        vuln = VulnerabilityFactory.create()
        vuln.custom_fields=None
        session.add(vuln)
        session.commit()

        res = test_client.get(self.url() + 'export_csv/')
        assert self._verify_csv(res.data)

    def _verify_csv(self, raw_csv_data, confirmed=False, severity=None):
        custom_fields = [custom_field.field_name for custom_field in CustomFieldsSchema.query.all()]
        vuln_headers = [
             "confirmed", "id", "date", "name", "severity", "service",
            "target", "desc", "status", "hostnames", "comments", "owner",
            "os", "resolution", "refs", "easeofresolution", "web_vulnerability",
            "data", "website", "path", "status_code", "request", "response", "method",
            "params", "pname", "query", "policyviolations", "external_id", "impact_confidentiality",
            "impact_integrity", "impact_availability", "impact_accountability", "update_date"
        ]
        host_and_service_headers = [
            "host_id", "host_description", "mac",
            "host_owned", "host_creator_id", "host_date", "host_update_date",
            "service_id", "service_name", "service_description", "service_owned",
            "port", "protocol", "summary", "version", "service_status",
            "service_creator_id", "service_date", "service_update_date", "service_parent_id"
        ]

        final_headers = vuln_headers + custom_fields + host_and_service_headers

        csv_data = csv.DictReader(StringIO(raw_csv_data.decode('utf-8')), delimiter=',')

        for index, line in enumerate(csv_data):
            if index == 0:
                csv_headers = list(line.keys())
                if csv_headers != final_headers:
                    return False
            else:
                # test vulns
                vuln = Vulnerability.query.filter_by(id=line['id'], confirmed=confirmed)
                if severity:
                    vuln.filter_by(severity=severity)

                vuln = vuln.first()
                if vuln.name != line['name']:
                    return False
                # test custom fields
                for c_index, custom_field in enumerate(custom_fields):
                    if vuln.custom_fields[custom_field] != line[custom_field]:
                        return False

                #test hosts
                host = Host.query.filter(Host.id == line['host_id']).first()
                if host.ip != line['target']:
                    return False

                # test services
                if line['service_id']:
                    service = Service.query.filter(Service.id == line['service_id']).first()
                    if service.summary != line['summary']:
                        return False

        return True

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_update_vuln_cant_change_tool(self, test_client, session):
        host = HostFactory.create(workspace=self.workspace)
        tool = "tool_name"
        updated_tool = "new_tool"
        vuln = VulnerabilityFactory.create(workspace=self.workspace, host_id=host.id, tool=tool)
        session.add(vuln)
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_put_data(
            'Updated vuln Name',
            'Updated vuln',
            'open',
            host.id,
            'Host',
        )
        raw_data.update({'tool': updated_tool})
        res = test_client.put(self.url(obj=vuln, workspace=self.workspace), data=raw_data)
        assert res.status_code == 200
        assert res.json['tool'] == tool




@pytest.mark.usefixtures('logged_user')
class TestCustomFieldVulnerability(ReadOnlyAPITests):  # TODO migration: use read write api tests
    model = Vulnerability
    factory = factories.VulnerabilityFactory
    api_endpoint = 'vulns'
    view_class = VulnerabilityView

    def test_create_vuln_with_custom_fields_shown(self, test_client, second_workspace, session):
        host = HostFactory.create(workspace=self.workspace)
        custom_field_schema = CustomFieldsSchemaFactory(
            field_name='cvss',
            field_type='str',
            field_display_name='CVSS',
            table_name='vulnerability'
        )
        session.add(host)
        session.add(custom_field_schema)
        session.commit()
        data = {
             'name': 'Test Alert policy_violations',
             'severity': 'informational',
             'creator': 'Zap',
             'parent_type': 'Host',
             'parent': host.id,
             'type': 'Vulnerability',
             'custom_fields': {
                'cvss': '321321',
             }
        }
        res = test_client.post(self.url(), data=data)

        assert res.status_code == 201
        assert res.json['custom_fields']['cvss'] == '321321'

    def test_create_vuln_with_custom_fields_using_field_display_name_fails(self, test_client, second_workspace, session):
        host = HostFactory.create(workspace=self.workspace)
        custom_field_schema = CustomFieldsSchemaFactory(
            field_name='cvss',
            field_type='str',
            field_display_name='CVSS',
            table_name='vulnerability'
        )
        session.add(host)
        session.add(custom_field_schema)
        session.commit()
        data = {
             'name': 'Test Alert policy_violations',
             'severity': 'informational',
             'creator': 'Zap',
             'parent_type': 'Host',
             'parent': host.id,
             'type': 'Vulnerability',
             'custom_fields': {
                'CVSS': '321321',  # here we use the field_name and not the display_name
             }
        }
        res = test_client.post(self.url(), data=data)

        assert res.status_code == 400

    def test_create_vuln_with_custom_fields_list(self, test_client, second_workspace, session):
        host = HostFactory.create(workspace=self.workspace)
        custom_field_schema = CustomFieldsSchemaFactory(
            field_name='changes',
            field_type='list',
            field_display_name='Changes',
            table_name='vulnerability'
        )
        session.add(host)
        session.add(custom_field_schema)
        session.commit()
        data = {
             'name': 'Test Alert policy_violations',
             'severity': 'informational',
             'creator': 'Zap',
             'parent_type': 'Host',
             'parent': host.id,
             'type': 'Vulnerability',
             'custom_fields': {
                'changes': ['1', '2', '3'],
             }
        }
        res = test_client.post(self.url(), data=data)

        assert res.status_code == 201
        assert res.json['custom_fields']['changes'] == ['1', '2', '3']

    def test_create_vuln_with_custom_fields_with_invalid_type_fails(self, test_client, second_workspace, session):
        host = HostFactory.create(workspace=self.workspace)
        custom_field_schema = CustomFieldsSchemaFactory(
            field_name='cvss',
            field_type='int',
            field_display_name='CVSS',
            table_name='vulnerability'
        )
        session.add(host)
        session.add(custom_field_schema)
        session.commit()
        data = {
             'name': 'Test Alert policy_violations',
             'severity': 'informational',
             'creator': 'Zap',
             'parent_type': 'Host',
             'parent': host.id,
             'type': 'Vulnerability',
             'custom_fields': {
                'CVSS': 'pepe',
             }
        }
        res = test_client.post(self.url(), data=data)

        assert res.status_code == 400

    def test_create_vuln_with_invalid_custom_fields_fails(self, test_client, second_workspace, session):
        host = HostFactory.create(workspace=self.workspace)
        session.add(host)
        session.commit()
        data = {
             'name': 'Test Alert policy_violations',
             'severity': 'informational',
             'creator': 'Zap',
             'parent_type': 'Host',
             'parent': host.id,
             'type': 'Vulnerability',
             'custom_fields': {
                'CVSS': '321321',
             }
        }
        res = test_client.post(self.url(), data=data)

        assert res.status_code == 400

    def test_create_create_vuln_web_with_host_as_parent_fails(
            self, host, session, test_client):
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='Empty desc',
            vuln_type='VulnerabilityWeb',
            parent_id=host.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 400

    def test_create_create_vuln_web_with_host_as_parent_fails_using_service_id(
            self, host, session, test_client):
        service = ServiceFactory.create(workspace=host.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='Empty desc',
            vuln_type='VulnerabilityWeb',
            parent_id=host.id,
            parent_type='Host',
            service_id=service.id,
            refs=[],
            policyviolations=[],
            description='',
            severity='low',
        )
        res = test_client.post(self.url(), data=raw_data)
        assert res.status_code == 400

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_bulk_delete_vuln_id(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data_vuln_1 = _create_post_data_vulnerability(
            name='New vuln 1',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld 1',
            severity='low',
        )
        raw_data_vuln_2 = _create_post_data_vulnerability(
            name='New vuln 2',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld 2',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res_1 = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data_vuln_1)
        res_2 = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data_vuln_2)
        vuln_1_id = res_1.json['obj_id']
        vuln_2_id = res_2.json['obj_id']
        vulns_to_delete = [vuln_1_id, vuln_2_id]
        request_data = {'vulnerability_ids': vulns_to_delete}
        delete_response = test_client.delete('/v2/ws/{0}/vulns/bulk_delete/'.format(ws_name), data=request_data)
        vuln_count_after = session.query(Vulnerability).count()
        deleted_vulns = delete_response.json['deleted_vulns']
        assert delete_response.status_code == 200
        assert vuln_count_previous == vuln_count_after
        assert deleted_vulns == len(vulns_to_delete)

    @pytest.mark.usefixtures('ignore_nplusone')
    def test_bulk_delete_vuln_severity(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data_vuln_1 = _create_post_data_vulnerability(
            name='New vuln 1',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld 1',
            severity='low',
        )
        raw_data_vuln_2 = _create_post_data_vulnerability(
            name='New vuln 2',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld 2',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res_1 = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data_vuln_1)
        res_2 = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data_vuln_2)
        vuln_1_id = res_1.json['obj_id']
        vuln_2_id = res_2.json['obj_id']
        vulns_to_delete = [vuln_1_id, vuln_2_id]
        request_data = {'severities': ['low']}
        delete_response = test_client.delete('/v2/ws/{0}/vulns/bulk_delete/'.format(ws_name), data=request_data)
        vuln_count_after = session.query(Vulnerability).count()
        deleted_vulns = delete_response.json['deleted_vulns']
        assert delete_response.status_code == 200
        assert vuln_count_previous == vuln_count_after
        assert deleted_vulns == len(vulns_to_delete)

    def test_create_vuln_with_tool(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        tool_name = "tool_name"
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
            tool=tool_name
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['tool'] == tool_name

    def test_create_vuln_without_tool(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = _create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['tool'] == "Web UI"

    def test_create_vuln_from_command_with_tool(self, test_client, session):
        command = EmptyCommandFactory.create(workspace=self.workspace)
        service = ServiceFactory.create(workspace=self.workspace)
        session.commit()
        tool = "tool_name"
        url = self.url(workspace=command.workspace) + '?' + urlencode({'command_id': command.id})
        raw_data = _create_post_data_vulnerability(
            name='Update vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='high',
            tool=tool
        )
        res = test_client.post(url, data=raw_data)
        assert res.status_code == 201
        assert len(command.command_objects) == 1
        cmd_obj = command.command_objects[0]
        assert cmd_obj.object_type == 'vulnerability'
        assert cmd_obj.object_id == res.json['_id']
        assert res.json['tool'] == tool

    def test_create_vuln_from_command_without_tool(self, test_client, session):
        command = EmptyCommandFactory.create(workspace=self.workspace)
        service = ServiceFactory.create(workspace=self.workspace)
        session.commit()
        url = self.url(workspace=command.workspace) + '?' + urlencode({'command_id': command.id})
        raw_data = _create_post_data_vulnerability(
            name='Update vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='high',
        )
        res = test_client.post(url, data=raw_data)
        assert res.status_code == 201
        assert len(command.command_objects) == 1
        cmd_obj = command.command_objects[0]
        assert cmd_obj.object_type == 'vulnerability'
        assert cmd_obj.object_id == res.json['_id']
        assert res.json['tool'] == command.tool



@pytest.mark.usefixtures('logged_user')
class TestVulnerabilityCustomFields(ReadOnlyAPITests):
    model = Vulnerability
    factory = factories.VulnerabilityFactory
    api_endpoint = 'vulns'
    view_class = VulnerabilityView

    def test_custom_field_cvss(self, session, test_client):
        add_text_field = CustomFieldsSchemaFactory.create(
            table_name='vulnerability',
            field_name='cvss',
            field_type='text',
            field_display_name='CVSS',
        )
        session.add(add_text_field)
        session.commit()


@pytest.mark.usefixtures('logged_user')
class TestVulnerabilitySearch():

    @pytest.mark.usefixtures('ignore_nplusone')
    @pytest.mark.skip_sql_dialect('sqlite')
    def test_search_by_hostname_vulns(self, test_client, session):
        workspace = WorkspaceFactory.create()
        host = HostFactory.create(workspace=workspace)
        host.hostnames.append(HostnameFactory.create(name='pepe', workspace=workspace))
        vuln = VulnerabilityFactory.create(host=host, service=None, workspace=workspace)
        session.add(vuln)
        session.add(host)
        session.commit()

        query_filter = {"filters":
            [{"name":"hostnames","op":"eq","val":"pepe"}]
        }
        res = test_client.get(
            '/v2/ws/{}/vulns/?q={}'.format(workspace.name, json.dumps(query_filter)))
        assert res.status_code == 200
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['id'] == vuln.id

    @pytest.mark.usefixtures('ignore_nplusone')
    @pytest.mark.skip_sql_dialect('sqlite')
    def test_search_by_hostname_vulns_with_service(self, test_client, session):
        workspace = WorkspaceFactory.create()
        host = HostFactory.create(workspace=workspace)
        host.hostnames.append(HostnameFactory.create(name='pepe', workspace=workspace))
        service = ServiceFactory.create(host=host, workspace=workspace)
        vuln = VulnerabilityFactory.create(host=None, service=service, workspace=workspace)
        session.add(vuln)
        session.add(host)
        session.commit()

        query_filter = {"filters":
            [{"name":"hostnames","op":"eq","val":"pepe"}]
        }
        res = test_client.get(
            '/v2/ws/{}/vulns/?q={}'.format(workspace.name, json.dumps(query_filter)))
        assert res.status_code == 200
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['id'] == vuln.id

    @pytest.mark.usefixtures('ignore_nplusone')
    @pytest.mark.skip_sql_dialect('sqlite')
    def test_search_hostname_web_vulns(self, test_client, session):
        workspace = WorkspaceFactory.create()
        host = HostFactory.create(workspace=workspace)
        host.hostnames.append(HostnameFactory.create(name='pepe', workspace=workspace))
        service = ServiceFactory.create(host=host, workspace=workspace)
        vuln = VulnerabilityWebFactory.create(service=service, workspace=workspace)
        session.add(vuln)
        session.add(host)
        session.commit()

        query_filter = {"filters":
                            [{"name": "hostnames", "op": "eq", "val": "pepe"}]
                        }
        res = test_client.get(
            '/v2/ws/{}/vulns/?q={}'.format(workspace.name, json.dumps(query_filter)))
        assert res.status_code == 200
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['id'] == vuln.id

    @pytest.mark.usefixtures('ignore_nplusone')
    @pytest.mark.skip_sql_dialect('sqlite')
    def test_search_by_hostname_multiple_logic(self, test_client, session):
        workspace = WorkspaceFactory.create()
        host = HostFactory.create(workspace=workspace)
        host.hostnames.append(HostnameFactory.create(name='pepe', workspace=workspace))
        vuln = VulnerabilityFactory.create(host=host, service=None, workspace=workspace)
        session.add(vuln)
        session.add(host)
        session.commit()

        query_filter = {"filters":[
            {"and": [{"name": "hostnames","op": "eq", "val": "pepe"}]}
        ]}
        res = test_client.get(
            '/v2/ws/{}/vulns/?q={}'.format(workspace.name, json.dumps(query_filter)))
        assert res.status_code == 200
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['id'] == vuln.id

    @pytest.mark.usefixtures('ignore_nplusone')
    @pytest.mark.skip_sql_dialect('sqlite')
    def test_search_by_hostname_and_confirmed(self, test_client, session):
        workspace = WorkspaceFactory.create()
        host = HostFactory.create(workspace=workspace)
        host.hostnames.append(HostnameFactory.create(name='pepe', workspace=workspace))
        vuln = VulnerabilityFactory.create(
            host=host,
            service=None,
            confirmed=True,
            workspace=workspace,
        )
        session.add(vuln)
        session.add(host)
        session.commit()

        query_filter = {"filters": [
            {"and": [
                {"name": "hostnames", "op": "eq", "val": "pepe"},
                {"name": "confirmed", "op": "==", "val": "true"}
            ]}
        ]}
        res = test_client.get(
            '/v2/ws/{}/vulns/?q={}'.format(workspace.name, json.dumps(query_filter)))
        assert res.status_code == 200
        assert res.json['count'] == 1
        assert res.json['vulnerabilities'][0]['id'] == vuln.id


def test_type_filter(workspace, session,
                     vulnerability_factory,
                     vulnerability_web_factory):
    filter_ = VulnerabilityFilterSet().filters['type']
    std_vulns = vulnerability_factory.create_batch(10, workspace=workspace)
    web_vulns = vulnerability_web_factory.create_batch(10, workspace=workspace)
    session.add_all(std_vulns)
    session.add_all(web_vulns)
    session.commit()

    std_filter = filter_.filter(VulnerabilityGeneric.query,
                                VulnerabilityGeneric,
                                'type',
                                'Vulnerability'
                                )
    assert {v.id for v in std_filter} == {v.id for v in std_vulns}

    web_filter = filter_.filter(VulnerabilityGeneric.query,
                                VulnerabilityGeneric,
                                'type',
                                'VulnerabilityWeb'
                                )
    assert {v.id for v in web_filter} == {v.id for v in web_vulns}


def test_creator_filter(workspace, session,
                        empty_command_factory, command_object_factory,
                        vulnerability_factory, vulnerability_web_factory):
    filter_ = VulnerabilityFilterSet().filters['creator']
    std_vulns = vulnerability_factory.create_batch(10,
                                                   workspace=workspace)[:5]
    session.add(workspace)
    web_vulns = vulnerability_web_factory.create_batch(10,
                                                       workspace=workspace)[:5]
    command = empty_command_factory.create(workspace=workspace,
                                           tool="metasploit")

    vulns = std_vulns + web_vulns
    session.add(command)
    session.add_all(vulns)
    session.commit()
    for vuln in vulns:
        command_object_factory.create(command=command,
                                      object_type='vulnerability',
                                      object_id=vuln.id,
                                      workspace=workspace)
    session.commit()

    filtered = filter_.filter(VulnerabilityGeneric.query,
                              VulnerabilityGeneric,
                              'creator',
                              'metasp')
    assert {v.id for v in filtered} == {v.id for v in vulns}


def test_service_filter(workspace, session, host, service_factory,
                        vulnerability_factory, vulnerability_web_factory):
    filter_ = VulnerabilityFilterSet().filters['service']

    vulnerability_factory.create_batch(5, host=host, service=None,
                                       workspace=workspace)
    other_service = service_factory.create(name='ftp', workspace=workspace)
    vulnerability_factory.create_batch(10, host=None, service=other_service,
                                       workspace=workspace)
    vulnerability_web_factory.create_batch(10, service=other_service,
                                           workspace=workspace)

    service = service_factory.create(name='http', workspace=workspace)
    vulns = []
    vulns = vulnerability_factory.create_batch(10, host=None, service=service,
                                               workspace=workspace)
    vulns += vulnerability_web_factory.create_batch(10, service=service,
                                                    workspace=workspace)
    session.commit()

    filtered = filter_.filter(VulnerabilityGeneric.query,
                              VulnerabilityGeneric,
                              'service',
                              'http')
    assert all(v.service and v.service.name == 'http'
               for v in filtered)
    assert {v.id for v in filtered} == {v.id for v in vulns}


def test_name_filter(workspace, session, host, vulnerability_factory):
    """Test case insensitivity and partial match detection"""
    filter_ = VulnerabilityFilterSet().filters['name']
    vulnerability_factory.create_batch(5, host=host, workspace=workspace)
    expected_vulns = vulnerability_factory.create_batch(
        5, host=host, workspace=workspace, name="Old OpenSSL version")
    session.add_all(expected_vulns)
    session.add(workspace)
    session.commit()
    filtered = filter_.filter(VulnerabilityGeneric.query,
                              VulnerabilityGeneric,
                              'name',
                              'openssl')
    assert {v.id for v in filtered} == {v.id for v in expected_vulns}


def vulnerability_json(parent_id, parent_type, vuln=None):
    vuln_dict = {
        'metadata': st.fixed_dictionaries({
            'update_time': st.floats(),
            'update_user': st.one_of(st.none(), st.text()),
            'update_action': st.integers(),
            'creator': st.text(),
            'create_time': st.floats(),
            'update_controller_action': st.text(),
            'owner': st.one_of(st.none(), st.text())}),
        'obj_id': st.integers(),
        'owner': st.one_of(st.none(), st.text()),
        'parent': st.sampled_from([parent_id]),
        'parent_type': st.sampled_from([parent_type]),
        'type': st.one_of(
            st.sampled_from([
            "Vulnerability", "Invalid", None]),
            st.text()
        ),
        'ws': st.one_of(st.none(), st.text()),
        'confirmed': st.booleans(),
        'data': st.one_of(st.none(), st.text()),
        'desc': st.one_of(st.none(), st.text()),
        'easeofresolution': st.sampled_from(['trivial',
            'simple',
            'moderate',
            'difficult',
            'infeasible']),
        'impact': st.fixed_dictionaries({'accountability': st.booleans(), 'availability': st.booleans(),
                  'confidentiality': st.booleans(),
                  'integrity': st.booleans()}),
        'name': st.one_of(st.none(), st.text()),
        'owned': st.booleans(),
        'policyviolations': st.lists(st.one_of(st.none(), st.text())),
        'refs': st.lists(st.one_of(st.none(), st.text())),
        'resolution': st.one_of(st.none(), st.text()),
        'severity': st.sampled_from(['critical',
            'high',
            'med',
            'medium',
            'low',
            'informational',
            'unclassified']),
        'status': st.sampled_from(['open',
            'closed',
            're-opened',
            'risk-accepted']),
        '_attachments': st.fixed_dictionaries({}),
        'description': st.one_of(st.none(), st.text()),
        'protocol': st.one_of(st.none(), st.text()),
        'version': st.one_of(st.none(), st.text())}
    if vuln:
        vuln_dict.update({
            '_id': st.integers(min_value=vuln.id, max_value=vuln.id),
            'id': st.integers(min_value=vuln.id, max_value=vuln.id)
            })
    return st.fixed_dictionaries(vuln_dict)


@pytest.mark.usefixtures('logged_user')
@pytest.mark.hypothesis
def test_hypothesis(host_with_hostnames, test_client, session):
    vuln = VulnerabilityFactory.create(workspace=host_with_hostnames.workspace)
    session.add(vuln)
    session.commit()
    VulnerabilityData = vulnerability_json(host_with_hostnames.id, 'Host')
    VulnerabilityDataWithId = vulnerability_json(host_with_hostnames.id, 'Host', vuln)

    @given(VulnerabilityData)
    def send_api_create_request(raw_data):

        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code in [201, 400, 409]

    @given(VulnerabilityDataWithId)
    def send_api_update_request(raw_data):

        ws_name = host_with_hostnames.workspace.name
        res = test_client.put('/v2/ws/{0}/vulns/{1}/'.format(ws_name, raw_data['_id']),
                               data=raw_data)
        assert res.status_code in [200, 400, 409, 405]

    send_api_create_request()
    send_api_update_request()


def test_model_converter():
    """Test that string fields are translated to NullToBlankString
    fields"""
    # Generic test. Think twice if you want to delete this
    field = VulnerabilitySchema().fields['data']
    assert isinstance(field, NullToBlankString)
    assert field.allow_none


# I'm Py3
